<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Spaces in Template ExpressionsThe requirement to put a space between two closing template expressions has gone 12vector&lt;list&lt;int&gt; &gt;; &#x2F;&#x2F; OK in each C++ versionvector&lt;list&lt;int&gt;&gt;;">
<meta property="og:type" content="article">
<meta property="og:title" content="CppImprovement">
<meta property="og:url" content="http://example.com/2017/09/07/CppImprovement/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Spaces in Template ExpressionsThe requirement to put a space between two closing template expressions has gone 12vector&lt;list&lt;int&gt; &gt;; &#x2F;&#x2F; OK in each C++ versionvector&lt;list&lt;int&gt;&gt;;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-09-07T14:50:54.000Z">
<meta property="article:modified_time" content="2020-03-22T08:16:35.963Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Cpp2.0">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2017/09/07/CppImprovement/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CppImprovement | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/09/07/CppImprovement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CppImprovement
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-07 22:50:54" itemprop="dateCreated datePublished" datetime="2017-09-07T22:50:54+08:00">2017-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-22 16:16:35" itemprop="dateModified" datetime="2020-03-22T16:16:35+08:00">2020-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Spaces-in-Template-Expressions"><a href="#Spaces-in-Template-Expressions" class="headerlink" title="Spaces in Template Expressions"></a>Spaces in Template Expressions</h2><p>The requirement to put a space between two closing template expressions has gone</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt;; <span class="comment">// OK in each C++ version</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;;  <span class="comment">// OK since C++11 </span></span><br></pre></td></tr></table></figure>
<h2 id="nullptr-and-std-nullptr-t"><a href="#nullptr-and-std-nullptr-t" class="headerlink" title="nullptr and std::nullptr_t"></a>nullptr and std::nullptr_t</h2><p>C++11 lets you use nullptr instead of 0 or NULL to specify that a pointer refers to no value (which differs from having an undefined value). This new feature especially helps to avoid mistakes that occurred when a null pointer was interpreted as an integral value. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line">f(<span class="number">0</span>); <span class="comment">// calls f(int)</span></span><br><span class="line">f(<span class="literal">NULL</span>); <span class="comment">// calls f(int) if NULL is 0, ambiguous otherwise</span></span><br><span class="line">f(<span class="literal">nullptr</span>); <span class="comment">// calls f(void*)</span></span><br></pre></td></tr></table></figure>
<p>nullptr is a new keyword. It automatically converts into each pointer type but not to any integral type. It has type std::nullptr_t, defined in <cstddef> (see Section 5.8.1, page 161), so you can now even overload operations for the case that a null pointer is passed. Note that std::nullptr_t counts as a fundamental data type (see Section 5.4.2, page 127).</p>
<h2 id="Automatic-Type-Deduction-with-auto"><a href="#Automatic-Type-Deduction-with-auto" class="headerlink" title="Automatic Type Deduction with auto"></a>Automatic Type Deduction with auto</h2><p>With C++11, you can declare a variable or an object without specifying its specific type by using auto.<br>For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>; <span class="comment">// i has type int</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> d = f(); <span class="comment">// d has type double</span></span><br></pre></td></tr></table></figure>
<p>The type of a variable declared with auto is deduced from its initializer. Thus, an initialization is required: auto i; // ERROR: can’t dedulce the type of i Additional qualifiers are allowed.<br>For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> vat = <span class="number">0.19</span>;</span><br></pre></td></tr></table></figure>
<p>Using auto is especially useful where the type is a pretty long and/or complicated expression.<br>For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> pos = v.begin(); <span class="comment">// pos has type vector&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> l = [] (<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123; <span class="comment">// l has the type of a lambda</span></span><br><span class="line">..., <span class="comment">// taking an int and returning a bool</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The latter is an object, representing a lambda</p>
<h2 id="Uniform-Initialization-and-Initializer-Lists"><a href="#Uniform-Initialization-and-Initializer-Lists" class="headerlink" title="Uniform Initialization and Initializer Lists"></a>Uniform Initialization and Initializer Lists</h2><p>Before C++11, programmers, especially novices, could easily become confused by the question of how to initialize a variable or an object. Initialization could happen with parentheses, braces, and/or assignment operators.<br>For this reason, C++11 introduced the concept of uniform initialization, which means that for any initialization, you can use one common syntax. This syntax uses braces, so the following is possible now:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> values[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; cities &#123;</span><br><span class="line"><span class="string">&quot;Berlin&quot;</span>, <span class="string">&quot;New York&quot;</span>, <span class="string">&quot;London&quot;</span>, <span class="string">&quot;Braunschweig&quot;</span>, <span class="string">&quot;Cairo&quot;</span>, <span class="string">&quot;Cologne&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; c&#123;<span class="number">4.0</span>,<span class="number">3.0</span>&#125;; <span class="comment">// equivalent to c(4.0,3.0)</span></span><br></pre></td></tr></table></figure>
<p>其实是利用一个事实：编译器看到{t1,t2…tn}便做出一个关联至一个initializer_list<T>,它关联至一个array&lt;T,n&gt;。调用函数（例如ctor）时该array内的元素可被编译器分解逐一传给函数。但若函数参数是个initializer_list<T>，调用者却不能给予数个T参数然后以为它们会被自动转为一个initializer_list<T>传入）</p>
<p>std::vector<a href="std::string">std::string</a> cities {“Berlin”, “New York”, “London”, “Braunschweig”, “Cairo”, “Cologne”};，这形成一个initializer_list<string>,背后有个array&lt;string,6&gt;。调用vector<string>ctors时编译器找到一个vector<string>ctor接受initializer_list<string>。所有容器皆有类似于此ctor。</p>
<p>std::complex<double> c{4.0,3.0}; // equivalent to c(4.0,3.0)<br>这形成一个initializer_list<double>，背后有个array&lt;double,2&gt;。调用complex<double>ctor时该array内的2个元素被分解传给ctor。complex<double>并无任何ctor接受initializer_list</p>
<p>An initializer list forces so-called value initialization, which means that even local variables of fundamental data types, which usually have an undefined initial value, are initialized by zero (or nullptr, if it is a pointer):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; <span class="comment">// i has undefined value</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;; <span class="comment">// j is initialized by 0</span></span><br><span class="line"><span class="keyword">int</span>* p; <span class="comment">// p has undefined value</span></span><br><span class="line"><span class="keyword">int</span>* q&#123;&#125;; <span class="comment">// q is initialized by nullptr</span></span><br></pre></td></tr></table></figure>
<p>Note, however, that narrowing initializations — those that reduce precision or where the supplied value gets modified— are not possible with braces. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>; <span class="comment">// OK, but OUCH: x1 becomes 5</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5.3</span>; <span class="comment">// OK, but OUCH: x2 becomes 5</span></span><br><span class="line"><span class="keyword">int</span> x3&#123;<span class="number">5.0</span>&#125;; <span class="comment">// ERROR: narrowing</span></span><br><span class="line"><span class="keyword">int</span> x4 = &#123;<span class="number">5.3</span>&#125;; <span class="comment">// ERROR: narrowing</span></span><br><span class="line"><span class="keyword">char</span> c1&#123;<span class="number">7</span>&#125;; <span class="comment">// OK: even though 7 is an int, this is not narrowing</span></span><br><span class="line"><span class="keyword">char</span> c2&#123;<span class="number">99999</span>&#125;; <span class="comment">// ERROR: narrowing (if 99999 doesn’t fit into a char)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 &#123; <span class="number">1</span>, <span class="number">2.3</span>, <span class="number">4</span>, <span class="number">5.6</span> &#125;; <span class="comment">// ERROR: narrowing doubles to ints</span></span><br></pre></td></tr></table></figure>
<p>To support the concept of initializer lists for user-defined types, C++11 provides the class template std::initializer_list&lt;&gt;. It can be used to support initializations by a list of values or in any other place where you want to process just a list of values. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> p=vals.begin(); p!=vals.end(); ++p) &#123; <span class="comment">// process a list of values</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print (&#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>&#125;); <span class="comment">// pass a list of values to print()</span></span><br><span class="line">传给<span class="built_in">initializer_list</span>者，一定必须也是个<span class="built_in">initializer_list</span>(<span class="keyword">or</span>&#123;&#125;形式)</span><br></pre></td></tr></table></figure>
<p>cpp1.0(none explicit one argument ctor 才可以做隐式转换)<br>explicit for ctors taking one argument<br>cpp2.0<br>explicit for ctors taking more than one argument</p>
<h2 id="range-based-for-statement"><a href="#range-based-for-statement" class="headerlink" title="range-based for statement"></a>range-based for statement</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( decl : coll ) &#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i : &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; ) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> elem : vec ) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; elem : vec ) &#123;</span><br><span class="line">  elem *= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Note that no explicit type conversions are possible when elements are initialized as decl inside the for loop. Thus, the following does not compile:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span>; <span class="comment">// explicit(!) type conversion from strings</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> C&amp; elem : vs) &#123; <span class="comment">// ERROR, no conversion from string to C defined</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="default-delete"><a href="#default-delete" class="headerlink" title="=default,=delete"></a>=default,=delete</h2><p>如果你自行定义了一个ctor，那么编译器就不会再给你一个default ctor。<br>如果你强制加上=default，就可以重新获得并使用default ctor。</p>
<h2 id="Alias-Template-template-typedef"><a href="#Alias-Template-template-typedef" class="headerlink" title="Alias Template ( template typedef )"></a>Alias Template ( template typedef )</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T,MyAlloc&lt;T&gt;&gt;;   <span class="comment">//standard vector using own allocator</span></span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; coll;</span><br><span class="line">is  equivalent to <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,MyAlloc&lt;<span class="keyword">int</span>&gt;&gt; coll;</span><br><span class="line">It is <span class="keyword">not</span> possible to partially <span class="keyword">or</span> explicitly specialize an alias <span class="keyword">template</span>.</span><br></pre></td></tr></table></figure>
<h2 id="Type-Alias-similar-to-typedef"><a href="#Type-Alias-similar-to-typedef" class="headerlink" title="Type Alias (similar to typedef)"></a>Type Alias (similar to typedef)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type alias,identical to</span></span><br><span class="line"><span class="comment">//typedef void (*func)(int,int);</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="keyword">void</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//the name &#x27;func&#x27; now denotes a pointer to function: void example(int,int)&#123;&#125;</span></span><br><span class="line">func fn = example;</span><br></pre></td></tr></table></figure>
<h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;   ==&gt;   <span class="keyword">void</span> foo() <span class="keyword">noexcept</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>declares that foo() won’t throw. If an exception is not handled locally inside foo() — thus, if foo() throws — the program is terminated, calling std::terminate(), which by default calls std::abort().</p>
<p>You can even specify a condition under which a function throws no exception. For example, for any type Type, the global swap() usually is defined as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(Type&amp; x, Type&amp; y)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(x.swap(y)))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x.swap(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, inside noexcept(…), you can specify a Boolean condition under which no exception gets thrown: Specifying noexcept without condition is a short form of specifying noexcept(true).</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8001823/how-to-enforce-move-semantics-when-a-vector-grows">https://stackoverflow.com/questions/8001823/how-to-enforce-move-semantics-when-a-vector-grows</a></p>
<h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>告诉编译器，子类要override父类的成员函数，让编译器帮助检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struce Base&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">(<span class="keyword">float</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> Base &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>&#123;&#125; <span class="comment">//[Error] marked override,bug does not override </span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> <span class="keyword">final</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived1</span> :</span> Base1&#123;&#125;;<span class="comment">//[Error] cannot derive from &#x27;final&#x27; base &#x27;Base1&#x27; in derived type &#x27;Derived1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> Base2&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//[Error] overriding final function &#x27;virtual void Base2::f()&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>By using the new decltype keyword, you can let the compiler find out the type of an expression. This is the realization of the often requested typeof feature. However, the existing typeof implementations were inconsistent and incomplete, so C++11 introduced a new keyword. For example:<br>GNU C++中的typeof并不是标准库的一部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem;</span><br><span class="line"></span><br><span class="line">这样写（before C++<span class="number">11</span>）</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">float</span>&gt;::value_type elem;</span><br></pre></td></tr></table></figure>
<p>One application of decltype is to declare return types (see below). Another is to use it in metaprogramming (see Section 5.4.1, page 125) or to pass the type of a lambda (see Section 10.3.4, page 504).</p>
<p>defines a type equivalent to the type of an expression</p>
<p>应用：<br>1、decltype,used to declare return types<br>Sometimes, the return type of a function depends on an expression processed with the arguments.<br>However, something like</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) add(T1 x, T2 y);</span><br></pre></td></tr></table></figure>
<p>was not possible before C++11, because the return expression uses objects not introduced or in scope yet.<br>But with C++11, you can alternatively declare the return type of a function behind the parameter list:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto add(T1 x, T2 y) -&gt; decltype(x+y);</span><br></pre></td></tr></table></figure>
<p>This uses the same syntax as for lambdas to declare return types<br>[…] (…) mutable_opt throwSpec_opt -&gt;retType_opt {…}<br>2、decltype, to used in metaprogramming<br>3、decltype, pass the type of a lambda<br>面对lambda，我们手上往往只有object，没有type。要获得其type就得借助于decltype。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Persion&amp; p1, <span class="keyword">const</span> Person&amp; p2) &#123;</span><br><span class="line">	<span class="keyword">return</span> p1.lastname() &lt; p2.lastname() ||</span><br><span class="line">		(p1.lastname() == p2.lastname() &amp;&amp;</span><br><span class="line">		p1.firstname() &lt; p2.firstname());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Person, <span class="keyword">decltype</span>(cmp)&gt;coll(cmp);</span><br></pre></td></tr></table></figure>

















<p>笔记来自 <a target="_blank" rel="noopener" href="http://boolan.com/">http://boolan.com/</a>  侯捷C++新标准C++11/14<br>内容引自《The C++ standard Library A Tutorial and reference》</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Cpp2-0/" rel="tag"># Cpp2.0</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/09/07/CppVariadicTemplates/" rel="prev" title="CppVariadicTemplates">
      <i class="fa fa-chevron-left"></i> CppVariadicTemplates
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/09/11/Lambdas/" rel="next" title="Lambdas">
      Lambdas <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spaces-in-Template-Expressions"><span class="nav-number">1.</span> <span class="nav-text">Spaces in Template Expressions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nullptr-and-std-nullptr-t"><span class="nav-number">2.</span> <span class="nav-text">nullptr and std::nullptr_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Automatic-Type-Deduction-with-auto"><span class="nav-number">3.</span> <span class="nav-text">Automatic Type Deduction with auto</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Uniform-Initialization-and-Initializer-Lists"><span class="nav-number">4.</span> <span class="nav-text">Uniform Initialization and Initializer Lists</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#range-based-for-statement"><span class="nav-number">5.</span> <span class="nav-text">range-based for statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#default-delete"><span class="nav-number">6.</span> <span class="nav-text">&#x3D;default,&#x3D;delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alias-Template-template-typedef"><span class="nav-number">7.</span> <span class="nav-text">Alias Template ( template typedef )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Type-Alias-similar-to-typedef"><span class="nav-number">8.</span> <span class="nav-text">Type Alias (similar to typedef)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noexcept"><span class="nav-number">9.</span> <span class="nav-text">noexcept</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#override"><span class="nav-number">10.</span> <span class="nav-text">override</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">11.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype"><span class="nav-number">12.</span> <span class="nav-text">decltype</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
